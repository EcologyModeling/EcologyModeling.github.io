<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Модели логистической регрессии</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>

<link rel="icon" type="image/png" href="images/favicon.png" />

<script type="text/javascript" src="js/rmarkdown.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="css\envmodel.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->





<div id="rStudioHeader" class="alwaysShrunk">
  <div class="innards bandContent">

      <a class="productName" href="index.html">Математическое моделрование в экологии
</a>


    <div id="menu">
      <div id="menuToggler"></div>
      <div id="menuItems">
        <a class="menuItem" href="Part-1-topic-1.html">Занятия</a>
        <a class="menuItem" href="Tests.html">Задания</a>
        <a class="menuItem" href="presentations/Introduction_R.html">Презентации</a>
        <a class="menuItem" href="materials.html">Материалы</a>
        <a class="menuItem gitHub" href="https://github.com/environemental-modelling/environemental-modelling.github.io"></a>
        <a class="menuItem gitHubText" href="https://github.com/environemental-modelling/environemental-modelling.github.io">Source on GitHub</a>
      </div>
    </div>
  </div>
</div>

<style type="text/css">
#TOC {
  margin-left: 35px;
  margin-top: 90px;
}
</style>

<script type="text/javascript">
$(".main-container").removeClass("main-container").removeClass("container-fluid").addClass("footerPushDown");
</script>


<div id="pageContent" class="standardPadding">
  <div class="articleBandContent">
<div class="lessonPage">
  <div class="lessonsNav">
    <a id="nav-lesson-1" href="Part-1-topic-1.html">Введение в программирование на языке R</a>
    <a id="nav-lesson-15" href="Part-2-topic-2.html">Физические модели. Формализация и численные решения.</a>
    <a id="nav-lesson-2" href="Part-3-topic-1.html">Выбор и оценка статистических методов моделирования </a>
    <a id="nav-lesson-3" href="Part-4-topic-1.html">Создание моделей линейной регрессии</a>
    <a id="nav-lesson-4" href="Part-4-topic-2.html">Модели логистической регрессии</a>

    <!--<a id="nav-lesson-5" href="lesson-5.html">Multiple regression modelling</a>
        <a id="nav-lesson-5" href="lesson-5.html">Всякое новое</a>
    <a id="nav-lesson-6" href="lesson-6.html">Parameters</a>
    <a id="nav-lesson-7" href="lesson-7.html">Tables</a>
    <a id="nav-lesson-8" href="lesson-8.html">Markdown Basics</a>
    <a id="nav-lesson-9" href="lesson-9.html">Output Formats</a>
    <a id="nav-lesson-10" href="lesson-10.html">Notebooks</a>
    <a id="nav-lesson-11" href="lesson-11.html">Slide Presentations</a>
    <a id="nav-lesson-12" href="lesson-12.html">Dashboards</a>
    <a id="nav-lesson-13" href="lesson-13.html">Websites</a>
    <a id="nav-lesson-14" href="lesson-14.html">Interactive Documents</a>
    <a id="nav-lesson-15" href="lesson-15.html">Cheatsheets</a>-->
  </div>
  <div class="lessonContent">

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Модели логистической регрессии</h1>

</div>


<div class="alert alert-danger" role="alert">
Раздел находится в разработке !
</div>
<div id="-" class="section level3">
<h3>Классификация данных</h3>
<table>
<colgroup>
<col width="41%" />
<col width="58%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p><em>Machine learning terminology</em></p></td>
<td><p><em>Typical Algorithm</em></p></td>
</tr>
<tr class="even">
<td><p>Classification: assigning known labels to objects</p></td>
<td><p>Decision trees Naive Bayes Logistic regression (witha threshold) Support vector machines</p></td>
</tr>
<tr class="odd">
<td><p>Regression: predicting or forecasting numerical values</p></td>
<td><p>Linear regression Logistic regression</p></td>
</tr>
<tr class="even">
<td><p>Association rules: finding objects that tend to appear in the data together</p></td>
<td><p>Apriori</p></td>
</tr>
<tr class="odd">
<td><p>Clustering: finding groups of objects that are more similar to each other than to objects in other groups</p></td>
<td><p>K-means</p></td>
</tr>
<tr class="even">
<td><p>Nearest neighbor: predicting property of a datum based on the datum or data that are most similar to it</p></td>
<td><p>Nearest neighbor</p></td>
</tr>
</tbody>
</table>
<p>When building a model, the first thing to check is if the model even works on the data it was trained from. In this section, we do this by introducing quantitative measures of model performance. From an evaluation point of view, we group model types this way.</p>
<ol style="list-style-type: decimal">
<li>Classification</li>
<li>Scoring</li>
<li>Probability estimation</li>
<li>Raking</li>
<li>Clustering</li>
</ol>
<table>
<colgroup>
<col width="13%" />
<col width="86%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Null model</p></td>
<td><p>A null model is the best model of a very simple form you’re trying to outperform. The two most typical null model choices are a model that is a single constant (returns the same answer for all situations) or a model that is independent (doesn’t record any important relation or interaction between inputs and outputs). We use null models to lower-bound desired performance, so we usually compare to a best null model. For example, in a categorical problem, the null model would always return the most popular category (as this is the easy guess that is least often wrong); for a score model, the null model is often the average of all the outcomes (as this has the least square deviation from all of the outcomes); and so on. The idea is this: if you’re not out-performing the null model, you’re not delivering value. Note that it can be hard to do as good as the best null model, because even though the null model is simple, it’s privileged to know the overall distribution of the items it will be quizzed on. We always assume the null model we’re comparing to is the best of all possible null models.</p></td>
</tr>
<tr class="even">
<td><p>Bayes rate model</p></td>
<td><p>A Bayes rate model (also sometimes called a saturated model) is a best possible model given the data at hand. The Bayes rate model is the perfect model and it only makes mistakes when there are multiple examples with the exact same set of known facts (same xs) but different outcomes (different ys). It isn’t always practical to construct the Bayes rate model, but we invoke it as an upper bound on a model evaluation score. If we feel our model is performing significantly above the null model rate and is approaching the Bayes rate, then we can stop tuning. When we have a lot of data and very few modeling features, we can estimate the Bayes error rate. Another way to estimate the Bayes rate is to ask several different people to score the same small sample of your data; the found inconsistency rate can be an estimate of the Bayes rate.a</p></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col width="28%" />
<col width="32%" />
<col width="40%" />
</colgroup>
<tbody>
<tr class="odd">
<td></td>
<td><p>Prediction=NEGATIVE</p></td>
<td><p>Prediction=POSITIVE</p></td>
</tr>
<tr class="even">
<td><p>Truth mark=NOT IN CATEGORY</p></td>
<td><p>True negatives (TN) cM[1,1]=264</p></td>
<td><p>False positives (FP) cM[1,2]=14</p></td>
</tr>
<tr class="odd">
<td><p>Truth mark=IN CATEGORY</p></td>
<td><p>False negatives (FN) cM[2,1]=22</p></td>
<td><p>True positives (TP) cM[2,2]=158</p></td>
</tr>
</tbody>
</table>
<table style="width:50%;">
<colgroup>
<col width="19%" />
<col width="30%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Measure</p></td>
<td><p>Formula</p></td>
</tr>
<tr class="even">
<td><p>Accuracy</p></td>
<td><p>(TP+TN)/(TP+FP+TN+FN)</p></td>
</tr>
<tr class="odd">
<td><p>Precision</p></td>
<td><p>TP/(TP+FP)</p></td>
</tr>
<tr class="even">
<td><p>Recall</p></td>
<td><p>TP/(TP+FN)</p></td>
</tr>
<tr class="odd">
<td><p>Sensitivity</p></td>
<td><p>TP/(TP+FN)</p></td>
</tr>
<tr class="even">
<td><p>Specificity</p></td>
<td><p>TN/(TN+FP)</p></td>
</tr>
</tbody>
</table>
</div>
<div id="make-a-table" class="section level3">
<h3>Make a table</h3>
<table>
<colgroup>
<col width="13%" />
<col width="86%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Measure</p></td>
<td><p>Typical business need Follow-up question Accuracy “We need most of our decisions to be correct.”“Can we tolerate being wrong 5% of the time? And do users see mistakes like spam marked as non-spam or non-spam marked as spam as being equivalent?”</p></td>
</tr>
<tr class="even">
<td><p>Precision</p></td>
<td><p>“Most of what we marked as spam had darn well better be spam.” That would guarantee that most of what is in the spam folder is in fact spam but it isn’t the best way to measure what fraction of the user’s legitimate email is lost. We could cheat on this goal by sending all our users a bunch of easy-to-identify spam that we correctly identify. Maybe we really want good specificity.”</p></td>
</tr>
<tr class="odd">
<td><p>Recall</p></td>
<td><p>“We want to cut down on the amount of spam a user sees by a factor of 10 (eliminate 90% of the spam).” “If 10% of the spam gets through, will the user see mostly non-spam mail or mostly spam? Will this result in a good user experience?”</p></td>
</tr>
<tr class="even">
<td><p>Sensitivity</p></td>
<td><p>“We have to cut a lot of spam, otherwise the user won’t see a benefit.” “If we cut spam down to 1% of what it is now,would that be a good user experience?”</p></td>
</tr>
<tr class="odd">
<td><p>Specificity</p></td>
<td><p>“We must be at least three nines on legitimate email; the user must see at least 99.9%of their non-spam email.” “Will the user tolerate missing 0.1% of their legitimate email, and should we keep a spam folder the user can look at?”</p></td>
</tr>
</tbody>
</table>
</div>
<div id="test-and-training-splits" class="section level3">
<h3>Test and training splits</h3>
<p>When you’re building a model to make predictions, like our model to predict the probability of health insurance coverage, you need data to build the model. You also need data to test whether the model makes correct predictions on new data. The first set is called the training set, and the second set is called the test (or hold-out) set. The training set is the data that you feed to the model-building algorithm—regression, decision trees, and so on—so that the algorithm can set the correct parameters to best predict the outcome variable. The test set is the data that you feed into the resulting model, to verify that the model’s predictions are accurate. We’ll go into detail about the kinds of modeling issues that you can detect by using hold-out data in chapter 5. For now, we’ll just get our data ready for doing hold-out experiments at a later stage.</p>
<p>Many writers recommend train/calibration/test splits, which is also good advice. Our philosophy is this: split the data into train/test early, don’t look at test until final evaluation, and if you need calibration data, resplit it from your training subset.</p>
</div>
<div id="correlation" class="section level3">
<h3>CORRELATION</h3>
<p>Correlation is very helpful in checking if variables are potentially useful in a model. Be advised that there are at least three calculations that go by the name of correlation: Pearson, Spearman, and Kendall (see help(cor)). The Pearson coefficient checks for linear relations, the Spearman coefficient checks for rank or ordered relations, and the Kendall coefficient checks for degree of voting agreement. Each of these coefficients performs a progressively more drastic transform than the one before and has well-known direct significance tests (see help(cor.test)).</p>
<p><strong><em>DON’T USE CORRELATION TO EVALUATE MODEL QUALITY IN PRODUCTION</em></strong></p>
<p>It’s tempting to use correlation to measure model quality, but we advise against it. The problem is this: correlation ignores shifts and scaling factors. So correlation is actually computing if there is any shift and rescaling of your predictor that is a good predictor. This isn’t a problem for training data (as these predictions tend to not have a systematic bias in shift or scaling by design) but can mask systematic errors that may arise when a model is used in production.</p>
<p><strong><em>THE WORST POSSIBLE MODELING OUTCOME</em></strong> The worst possible modeling outcome is not failing to find a good model. The worst possible modeling outcome is thinking you have a good model when you don’t. One of the easiest ways to accidentally build such a deficient model is to have an instrumental or independent variable that is in fact a subtle function of the outcome. Such variables can easily leak into your training data, especially when you have no knowledge or control of variable meaning preparation. The point is this: such variables won’t actually be available in a real deployment and often are in training data packaged up by others.</p>
</div>
<div id="logistic-regression" class="section level3">
<h3>Logistic regression</h3>
<p>Logistic regression is the most important (and probably most used) member of a class of models called generalized linear models. Unlike linear regression, logistic regression can directly predict values that are restricted to the (0,1) interval, such as probabilities. It’s the go-to method for predicting probabilities or rates, and like linear regression, the coefficients of a logistic regression model can be treated as advice. It’s also a good first choice for binary classification problems.</p>
<p>In this section, we’ll use a medical classification example (predicting whether a newborn will need extra medical attention) to work through all of the steps of producing and using a logistic regression model.</p>
<p>Understanding logistic regression</p>
<p>Logistic regression predicts the probability y that an instance belongs to a specific category— for instance, the probability that a flight will be delayed. When x[i,] is a row of inputs (for example, a flight’s origin and destination, the time of year, the weather, the air carrier), logistic regression finds a fit function f(x) such that</p>
<p>P[y[i] in class] ~ f(x[i,]) = s(a+b[1] x[i,1] + … b[n] x[i,n])</p>
<p>Here, s(z) is the so-called sigmoid function, defined as s(z) = 1/(1+exp(z)). If the y[i] are the probabilities that the x[i,] belong to the class of interest (in our example, that a flight with certain characteristics will be delayed), then the task of fitting is to find the b[1], …, b[n] such that f(x[i,]) is the best possible estimate of y[i]. R supplies a one-line command to find these coefficients: glm().4 Note that we don’t need to supply y[i] that are probability estimates to run glm(); the training method only requires y[i] that say whether a given training example is in the target class. The sigmoid function maps real numbers to the interval (0,1)—that is, to probabilities. The inverse of the sigmoid is the logit, which is defined as log(p/(1-p)), where p is a probability. The ratio p/(1-p) is known as the odds, so in the flight example, the logit is the log of the odds (or log-odds) that a flight will be delayed. In other words, you can think of logistic regression as a linear regression that finds the log-odds of the probability that you’re interested in.</p>
<p>Logistic regression is usually used to perform classification, but logistic regression and its close cousin beta regression are also useful in estimating rates. In fact, R’s standard glm() call will work with prediction numeric values between 0 and 1.0 in addition to predicting classifications. Logistic regression can be used for classifying into any number of categories (as long as the categories are disjoint and cover all possibilities: every x has to belong to one of the given categories). But glm() only handles the two-category case, so our discussion will focus on this case.</p>
<p>In particular, logistic regression assumes that logit(y) is linear in the values of x. Like linear regression, logistic regression will find the best coefficients to predict y, including finding advantageous combinations and cancellations when the inputs are correlated.</p>
<p>For the example task, imagine that you’re working at a hospital. The goal is to design a plan that provisions neonatal emergency equipment to delivery rooms. Newborn babies are assessed at one and five minutes after birth using what’s called the Apgar test, which is designed to determine if a baby needs immediate emergency care or extra medical attention. A baby who scores below 7 (on a scale from 0 to 10) on the Apgar scale needs extra attention.</p>
<p>Such at-risk babies are rare, so the hospital doesn’t want to provision extra emergency equipment for every delivery. On the other hand, at-risk babies may need attention quickly, so provisioning resources proactively to appropriate deliveries can save lives. The goal of this project is to identify ahead of time situations with a higher probability of risk, so that resources can be allocated appropriately</p>
<pre class="r"><code>sdata = read.csv(&quot;https://www.dropbox.com/s/lx9celfieswn4vq/NatalRisk.csv?dl=1&quot;)
head(sdata)</code></pre>
<pre><code>##      X PWGT UPREVIS CIG_REC    GESTREC3 DPLURAL ULD_MECO ULD_PRECIP
## 1 2136  155      14   FALSE &gt;= 37 weeks  single     TRUE      FALSE
## 2 2137  140      13   FALSE &gt;= 37 weeks  single    FALSE      FALSE
## 3 2138  151      15   FALSE &gt;= 37 weeks  single    FALSE      FALSE
## 4 2139  118       4   FALSE &gt;= 37 weeks  single    FALSE      FALSE
## 5 2140  134      11   FALSE &gt;= 37 weeks  single    FALSE      FALSE
## 6 2141  117      18   FALSE &gt;= 37 weeks  single     TRUE      FALSE
##   ULD_BREECH URF_DIAB URF_CHYPER URF_PHYPER URF_ECLAM atRisk DBWT
## 1      FALSE    FALSE      FALSE      FALSE     FALSE  FALSE 3714
## 2      FALSE    FALSE      FALSE      FALSE     FALSE  FALSE 3715
## 3      FALSE    FALSE      FALSE      FALSE     FALSE  FALSE 3447
## 4      FALSE    FALSE      FALSE      FALSE     FALSE  FALSE 3175
## 5      FALSE    FALSE      FALSE      FALSE     FALSE  FALSE 4038
## 6      FALSE    FALSE      FALSE      FALSE     FALSE  FALSE 3410
##   ORIGRANDGROUP
## 1             2
## 2             4
## 3             2
## 4             6
## 5            10
## 6             7</code></pre>
<pre class="r"><code>train &lt;- sdata[sdata$ORIGRANDGROUP&lt;=5,]
test &lt;- sdata[sdata$ORIGRANDGROUP&gt;5,]</code></pre>
<p>The command to build a logistic regression model in R is glm(). In our case, the dependent variable y is the logical (or Boolean) atRisk; all the other variables in table 7.1 are the independent variables x. The formula for building a model to predict atRisk using these variables is rather long to type in by hand; you can generate the formula with the commands shown in the next listing.</p>
<pre class="r"><code>complications &lt;- c(&quot;ULD_MECO&quot;,&quot;ULD_PRECIP&quot;,&quot;ULD_BREECH&quot;)
riskfactors &lt;- c(&quot;URF_DIAB&quot;, &quot;URF_CHYPER&quot;, &quot;URF_PHYPER&quot;,
  &quot;URF_ECLAM&quot;)
  y &lt;- &quot;atRisk&quot;
  x &lt;- c(&quot;PWGT&quot;,
  &quot;UPREVIS&quot;,
  &quot;CIG_REC&quot;,
  &quot;GESTREC3&quot;,
  &quot;DPLURAL&quot;,
  complications,
  riskfactors)
fmla &lt;- paste(y, paste(x, collapse=&quot;+&quot;), sep=&quot;~&quot;)

model &lt;- glm(fmla, data=train, family=binomial(link=&quot;logit&quot;))</code></pre>
<p>The family function specifies the assumed distribution of the dependent variable y. In our case, we’re modeling y as a binomial distribution, or as a coin whose probability of heads depends on x. The link function “links” the output to a linear model—pass y through the link function, and then model the resulting value as a linear function of the x values. Different combinations of family functions and link functions lead to different kinds of generalized linear models (for example, Poisson, or probit). In this book, we’ll only discuss logistic models, so we’ll only need to use the binomial family with the logit link.</p>
<p>Making predictions with a logistic model is similar to making predictions with a linear model—use the predict() function.</p>
<pre class="r"><code>train$pred &lt;- predict(model, newdata=train, type=&quot;response&quot;)
test$pred &lt;- predict(model, newdata=test, type=&quot;response&quot;)</code></pre>
<p>We’ve again stored the predictions for the training and test sets as the column pred in the respective data frames. Note the additional parameter type=“response”. This tells the predict() function to return the predicted probabilities y. If you don’t specify type=“response”, then by default predict() will return the output of the link function, logit(y).</p>
<p>One strength of logistic regression is that it preserves the marginal probabilities of the training data. That means that if you sum up the predicted probability scores for the entire training set, that quantity will be equal to the number of positive outcomes (atRisk == T) in the training set. This is also true for subsets of the data determined by variables included in the model. For example, in the subset of the training data that has train$GESTREC==“&lt;37 weeks” (the baby was premature), the sum of the predicted probabilities equals the number of positive training examples.</p>
<p>If our goal is to use the model to classify new instances into one of two categories (in this case, at-risk or not-at-risk), then we want the model to give high scores to positive instances and low scores otherwise. We can check if this is so by plotting the distribution of scores for both the positive and negative instances. Let’s do this on the training set (we should also plot the test set, to make sure that the performance is of similar quality).</p>
<pre class="r"><code>library(ggplot2)
ggplot(train, aes(x=pred, color=atRisk, linetype=atRisk)) + geom_density()</code></pre>
<p><img src="Part-4-topic-2_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>The result is shown in figure 7.9. Ideally, we’d like the distribution of scores to be separated, with the scores of the negative instances (FALSE) to be concentrated on the left, and the distribution for the positive instances to be concentrated on the right. Earlier we showed an example of a classifier that separates the positives and the negativesquite well in figure 5.8. In the current case, both distributions are concentrated on the left, meaning that both positive and negative instances score low. This isn’t surprising, since the positive instances (the ones with the baby at risk) are rare (about 1.8% of all births in the dataset). The distribution of scores for the negative instances dies off sooner than the distribution for positive instances. This means that the model did identify subpopulations in the data where the rate of at-risk newborns is higher than the average.</p>
<p>In order to use the model as a classifier, you must pick a threshold; scores above the threshold will be classified as positive, those below as negative. When you pick a threshold, you’re trying to balance the precision of the classifier (what fraction of the predicted positives are true positives) and its recall (how many of the true positives the classifier finds)</p>
<p>If the score distributions of the positive and negative instances are well separated, as in figure 5.8, we can pick an appropriate threshold in the “valley” between the two peaks. In the current case, the two distributions aren’t well separated, which indicates that the model can’t build a classifier that simultaneously achieves good recall and good precision. But we can build a classifier that identifies a subset of situations with a higher-than-average rate of at-risk births, so preprovisioning resources to those situations may be advised. We’ll call the ratio of the classifier precision to the average rate of positives the enrichment rate. The higher we set the threshold, the more precise the classifier will be (we’ll identify a set of situations with a much higher-than-average rate of at-risk births); but we’ll also miss a higher percentage of at-risk situations, as well. When picking the threshold, we’ll use the training set, since picking the threshold is part of classifier-building.</p>
<p>We can then use the test set to evaluate classifier performance. To help pick the threshold, we can use a plot like figure 7.10, which shows both enrichment and recall as a functions of the threshold. Looking at figure 7.10, you see that higher thresholds result in more precise classifications, at the cost of missing more cases; a lower threshold will identify more cases, at the cost of many more false positives. The best trade-off between precision and recall is a function of how many resources the hospital has available to allocate, and how many they can keep in reserve (or redeploy) for situations that the classifier missed. A threshold of 0.02 (which incidentally is about the overall rate of at-risk births in the training data) might be a good trade-off. The resulting classifier will identify a set of potential at-risk situations that finds about half of all the true at-risk situations, with a true positive rate 2.5 times higher than the overall population</p>
<pre class="r"><code>library(ROCR)</code></pre>
<pre><code>## Warning: package &#39;ROCR&#39; was built under R version 3.3.3</code></pre>
<pre><code>## Loading required package: gplots</code></pre>
<pre><code>## Warning: package &#39;gplots&#39; was built under R version 3.3.3</code></pre>
<pre><code>## 
## Attaching package: &#39;gplots&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:stats&#39;:
## 
##     lowess</code></pre>
<pre class="r"><code>library(grid) # Load grid library (you’ll need this  for the nplot function below).
predObj &lt;- prediction(train$pred, train$atRisk) # Create ROCR prediction object
precObj &lt;- performance(predObj, measure=&quot;prec&quot;) # Create ROCR object to calculate precision as a function of threshold
recObj &lt;- performance(predObj, measure=&quot;rec&quot;)# Create ROCR object to calculate recall as a function of threshold.
precision &lt;- (precObj@y.values)[[1]] # ROCR objects are what R calls S4 objects; the slots (or fields) of an S4 object are stored as lists within the object. You extract the slots from an S4 object using @ notation. 
prec.x &lt;- (precObj@x.values)[[1]] # The x values (thresholds) are the same in both predObj and recObj, so you only need to extract them once.
recall &lt;- (recObj@y.values)[[1]]
rocFrame &lt;- data.frame(threshold=prec.x, precision=precision, recall = recall) # Build data frame with thresholds, precision, and recall
nplot &lt;- function(plist) { #Function to plot multiple plots on one page (stacked).
  n &lt;- length(plist)
  grid.newpage()
  pushViewport(viewport(layout=grid.layout(n,1)))
  vplayout=function(x,y) {viewport(layout.pos.row=x, layout.pos.col=y)}
  for(i in 1:n) {
    print(plist[[i]], vp=vplayout(i,1))
    }
}
pnull &lt;- mean(as.numeric(train$atRisk)) # Calculate rate of at-risk births in the training set.
p1 &lt;- ggplot(rocFrame, aes(x=threshold)) + # Plot enrichment rate as a function of threshold.
geom_line(aes(y=precision/pnull)) +
coord_cartesian(xlim = c(0,0.05), ylim=c(0,10) )


p2 &lt;- ggplot(rocFrame, aes(x=threshold)) + # Plot recall as a function of threshold
geom_line(aes(y=recall)) +
coord_cartesian(xlim = c(0,0.05) )
nplot(list(p1, p2)) #Show both plots simultaneously.</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_path).</code></pre>
<p><img src="Part-4-topic-2_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>Once we’ve picked an appropriate threshold, we can evaluate the resulting classifier by looking at the confusion matrix, as we discussed in section 5.2.1. Let’s use the test set to evaluate the classifier, with a threshold of 0.02.</p>
<pre class="r"><code>ctab.test &lt;- table(pred=test$pred&gt;0.02, atRisk=test$atRisk)
ctab.test</code></pre>
<pre><code>##        atRisk
## pred    FALSE TRUE
##   FALSE  9487   93
##   TRUE   2405  116</code></pre>
<pre class="r"><code>precision &lt;- ctab.test[2,2]/sum(ctab.test[2,])
precision</code></pre>
<pre><code>## [1] 0.04601349</code></pre>
<pre class="r"><code>recall &lt;- ctab.test[2,2]/sum(ctab.test[,2])
recall</code></pre>
<pre><code>## [1] 0.5550239</code></pre>
<pre class="r"><code>enrich &lt;- precision/mean(as.numeric(test$atRisk))
enrich</code></pre>
<pre><code>## [1] 2.664159</code></pre>
<p>The resulting classifier is low-precision, but identifies a set of potential at-risk cases that contains 55.5% of the true positive cases in the test set, at a rate 2.66 times higher than the overall average. This is consistent with the results on the training set.</p>
<p>The coefficients of a logistic regression model encode the relationships between the input variables and the output in a way similar to how the coefficients of a linear regression model do. You can get the model’s coefficients with the call coefficients(model).</p>
<pre class="r"><code>coefficients(model)</code></pre>
<pre><code>##              (Intercept)                     PWGT                  UPREVIS 
##              -2.86700629               0.00376166              -0.06328943 
##              CIG_RECTRUE      GESTREC3&gt;= 37 weeks DPLURALtriplet or higher 
##               0.31316930              -1.54518311               1.39419294 
##              DPLURALtwin             ULD_MECOTRUE           ULD_PRECIPTRUE 
##               0.31231871               0.81842627               0.19172008 
##           ULD_BREECHTRUE             URF_DIABTRUE           URF_CHYPERTRUE 
##               0.74923672              -0.34646672               0.56002503 
##           URF_PHYPERTRUE            URF_ECLAMTRUE 
##               0.16159872               0.49806435</code></pre>
<p>Negative coefficients that are statistically significant6 correspond to variables that are negatively correlated to the odds (and hence to the probability) of a positive outcome (the baby being at risk). Positive coefficients that are statistically significant are positively correlated to the odds of a positive outcome. As with linear regression, every categorical variable is expanded to a set of indicator variables. If the original variable has n levels, there will be n-1 indicator variables; the remaining level is the reference level. For example, the variable DPLURAL has three levels corresponding to single births, twins, and triplets or higher. The logistic regression model has two corresponding coefficients: DPLURALtwin and DPLURALtriplet or higher. The reference level is single births. Both of the DPLURAL coefficients are positive, indicating that multiple births have higher odds of being at risk than single births do, all other variables being equal.</p>
</div>
<div id="interpreting-the-coefficients" class="section level3">
<h3>INTERPRETING THE COEFFICIENTS</h3>
<p>Interpreting coefficient values is a little more complicated with logistic than with linear regression. If the coefficient for the variable x[,k] is b[k], then the odds of a positive outcome are multiplied by a factor of exp(b[k]) for every unit change in x[,k]. The coefficient for GESTREC3&lt; 37 weeks (for a premature baby) is 1.545183. So for a premature baby, the odds of being at risk are exp(1.545183)=4.68883 times higher compared to a baby that’s born full-term, with all other input variables unchanged. As an example, suppose a full-term baby with certain characteristics has a 1% probability of being at risk (odds are p/(1-p), or 0.01/0.99 = 0.0101); then the odds for a premature baby with the same characteristics are 0.0101<em>4.68883 = 0.047. This corresponds to a probability of being at risk of odds/(1+odds), or 0.047/ 1.047—about 4.5%. Similarly, the coefficient for UPREVIS (number of prenatal medical visits) is about -0.06. This means every prenatal visit lowers the odds of an at-risk baby by a factor of exp(-0.06), or about 0.94. Suppose the mother of our premature baby had made no prenatal visits; a baby in the same situation whose mother had made three prenatal visits would have odds of being at risk of about 0.047 </em> 0.94 * 0.94 * 0.94 = 0.039. This corresponds to a probability of being at risk of 3.75%. So the general advice in this case might be to keep a special eye on premature births (and multiple births), and encourage expectant mothers to make regular prenatal visits</p>
</div>
<div id="reading-the-model-summary-and-characterizing-coefficients" class="section level3">
<h3>Reading the model summary and characterizing coefficients</h3>
<p>As we mentioned earlier, conclusions about the coefficient values are only to be trusted if the coefficient values are statistically significant. We also want to make sure that the model is actually explaining something. The diagnostics in the model summary will help us determine some facts about model quality. The call, as before, is summary(model).</p>
<pre class="r"><code>summary(model)</code></pre>
<pre><code>## 
## Call:
## glm(formula = fmla, family = binomial(link = &quot;logit&quot;), data = train)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -0.9732  -0.1818  -0.1511  -0.1358   3.2641  
## 
## Coefficients:
##                           Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)              -2.867006   0.285007 -10.059  &lt; 2e-16 ***
## PWGT                      0.003762   0.001487   2.530 0.011417 *  
## UPREVIS                  -0.063289   0.015252  -4.150 3.33e-05 ***
## CIG_RECTRUE               0.313169   0.187230   1.673 0.094398 .  
## GESTREC3&gt;= 37 weeks      -1.545183   0.140795 -10.975  &lt; 2e-16 ***
## DPLURALtriplet or higher  1.394193   0.498866   2.795 0.005194 ** 
## DPLURALtwin               0.312319   0.241088   1.295 0.195163    
## ULD_MECOTRUE              0.818426   0.235798   3.471 0.000519 ***
## ULD_PRECIPTRUE            0.191720   0.357680   0.536 0.591951    
## ULD_BREECHTRUE            0.749237   0.178129   4.206 2.60e-05 ***
## URF_DIABTRUE             -0.346467   0.287514  -1.205 0.228187    
## URF_CHYPERTRUE            0.560025   0.389678   1.437 0.150676    
## URF_PHYPERTRUE            0.161599   0.250003   0.646 0.518029    
## URF_ECLAMTRUE             0.498064   0.776948   0.641 0.521489    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 2698.7  on 14211  degrees of freedom
## Residual deviance: 2463.0  on 14198  degrees of freedom
## AIC: 2491
## 
## Number of Fisher Scoring iterations: 7</code></pre>
<p>In linear regression, the residuals are the vector of differences between the true outcome values and the predicted output values (the errors). In logistic regression, the deviance residuals are related to the log likelihoods of having observed the true outcome, given the predicted probability of that outcome. The idea behind log likelihood is that positive instances y should have high probability py of occurring under the model; negative instances should have low probability of occurring (or putting it another way, (1-py) should be large). The log likelihood function rewards “matches” between the outcome y and the predicted probability py, and penalizes mismatches (high py for negative instances, and vice versa).</p>
<pre class="r"><code>pred &lt;- predict(model, newdata=train, type=&quot;response&quot;)
llcomponents &lt;- function(y, py) { y*log(py) + (1-y)*log(1-py)} # Function to return the log likelihoods for each data point. Argument y is the true outcome
                                                               # (as a numeric variable, 0/1); argument py is the predicted probability.
edev &lt;- sign(as.numeric(train$atRisk) - pred) * sqrt(-2*llcomponents(as.numeric(train$atRisk), pred)) # Calculate deviance result

summary(edev)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## -0.9732 -0.1818 -0.1511 -0.1244 -0.1358  3.2640</code></pre>
<p>Linear regression models are found by minimizing the sum of the squared residuals; logistic regression models are found by minimizing the sum of the squared residual deviances, which is equivalent to maximizing the log likelihood of the data, given the model.</p>
<p>Logistic models can also be used to explicitly compute rates: given several groups of identical data points (identical except the outcome), predict the rate of positive outcomes in each group. This kind of data is called grouped data. In the case of grouped data, the deviance residuals can be used as a diagnostic for model fit. This is why the deviance residuals are included in the summary. We’re using ungrouped data— every data point in the training set is potentially unique. In the case of ungrouped data, the model fit diagnostics that use the deviance residuals are no longer valid</p>
<p>The summary coefficients table for logistic regression has the same format as the coefficients table for linear regression The columns of the table represent  A coefficient  Its estimated value  The error around that estimate  The signed distance of the estimated coefficient value from 0 (using the standard error as the unit of distance)  The probability of seeing a coefficient value at least as large as we observed, under the null hypothesis that the coefficient value is really 0</p>
<p>This last value, called the p-value or significance, tells us whether we should trust the estimated coefficient value. The standard rule of thumb is that coefficients with p-values less than 0.05 are reliable, although some researchers prefer stricter thresholds. For the birth data, we can see from the coefficient summary that premature birth and triplet birth are strong predictors of the newborn needing extra medical attention: the coefficient magnitudes are non-negligible and the p-values indicate significance. Other variables that affect the outcome are the mother’s prepregnancy weight (heavier mothers indicate higher risk—slightly surprising); the number of prenatal medical visits (the more visits, the lower the risk); meconium staining in the amniotic fluid; and breech position at birth. There might be a positive correlation between mother’s smoking and an at-risk birth, but the data doesn’t indicate it definitively. None of the other variables show a strong relationship to an at-risk birth</p>
<p>Deviance is again a measure of how well the model fits the data. It is 2 times the negative log likelihood of the dataset, given the model. If you think of deviance as analogous to variance, then the null deviance is similar to the variance of the data around the average rate of positive examples. The residual deviance is similar to the variance of the data around the model. We can calculate the deviances for both the training and test sets.</p>
<pre class="r"><code>loglikelihood &lt;- function(y, py) {
  sum(y * log(py) + (1-y)*log(1 - py))
}
# Function to calculate the log likelihood of a dataset. Variable y is the outcome in numeric form (1 for positive examples, 0 for negative). Variable py is
# the predicted probability that y==1.

pnull &lt;- mean(as.numeric(train$atRisk))
pnull</code></pre>
<pre><code>## [1] 0.01920912</code></pre>
<pre class="r"><code>null.dev &lt;- -2*loglikelihood(as.numeric(train$atRisk), pnull)
null.dev</code></pre>
<pre><code>## [1] 2698.716</code></pre>
<pre class="r"><code>model$null.deviance</code></pre>
<pre><code>## [1] 2698.716</code></pre>
<pre class="r"><code>pred &lt;- predict(model, newdata=train, type=&quot;response&quot;) #Predict probabilities for training data.
resid.dev &lt;- 2*loglikelihood(as.numeric(train$atRisk), pred) # Calculate deviance of model for training data

resid.dev</code></pre>
<pre><code>## [1] -2462.992</code></pre>
<pre class="r"><code>model$deviance # For training data, model deviance is stored in the slot model$deviance</code></pre>
<pre><code>## [1] 2462.992</code></pre>
<pre class="r"><code>testy &lt;- as.numeric(test$atRisk) # Calculate null deviance  and residual deviance for test data.
testpred &lt;- predict(model, newdata=test,
type=&quot;response&quot;)
pnull.test &lt;- mean(testy)
null.dev.test &lt;- -2*loglikelihood(testy, pnull.test)
resid.dev.test &lt;- -2*loglikelihood(testy, testpred)

pnull.test</code></pre>
<pre><code>## [1] 0.0172713</code></pre>
<pre class="r"><code>null.dev.test</code></pre>
<pre><code>## [1] 2110.91</code></pre>
<pre class="r"><code>resid.dev.test</code></pre>
<pre><code>## [1] 1947.094</code></pre>
<p>The first thing we can do with the null and residual deviances is check whether the model’s probability predictions are better than just guessing the average rate of positives, statistically speaking. In other words, is the reduction in deviance from the model meaningful, or just something that was observed by chance? This is similar to calculating the F-test statistics that are reported for linear regression. In the case of logistic regression, the test you’ll run is the chi-squared test. To do that, you need to know the degrees of freedom for the null model and the actual model (which are reported in the summary). The degrees of freedom of the null model is the number of data points minus 1: df.null = dim(train)[[1]] - 1. The degrees of freedom of the model that you fit is the number of data points minus the number of coefficients in the model: df.model = dim(train)[[1]] - length(model$coefficients).</p>
<p>If the number of data points in the training set is large, and df.null - df.model is small, then the probability of the difference in deviances null.dev - resid.dev being as large as we observed is approximately distributed as a chi-squared distribution with df.null - df.model degrees of freedom.</p>
<pre class="r"><code>df.null &lt;- dim(train)[[1]] - 1 # Null model has (number of data points - 1) degrees of freedom.
df.model &lt;- dim(train)[[1]] - length(model$coefficients) # Fitted model has (number of data points - number of coefficients) degrees of freedom.

df.null</code></pre>
<pre><code>## [1] 14211</code></pre>
<pre class="r"><code>df.model</code></pre>
<pre><code>## [1] 14198</code></pre>
<pre class="r"><code>delDev &lt;- null.dev - resid.dev
deldf &lt;- df.null - df.model # Compute difference in deviances and difference in degrees of freedom.
p &lt;- pchisq(delDev, deldf, lower.tail=F) # Estimate probability of seeing the observed difference in deviances under null model (the p-value)
                                         # using chi-squared distribution.

delDev</code></pre>
<pre><code>## [1] 5161.708</code></pre>
<pre class="r"><code>deldf</code></pre>
<pre><code>## [1] 13</code></pre>
<pre class="r"><code>p</code></pre>
<pre><code>## [1] 0</code></pre>
<p>A useful goodness of fit measure based on the deviances is the pseudo R-squared: 1 - (dev.model/dev.null). The pseudo R-squared is the analog to the R-squared measure for linear regression. It’s a measure of how much of the deviance is “explained” by the model. Ideally, you want the pseudo R-squared to be close to 1. Let’s calculate the pseudo-R-squared for both the test and training data.</p>
<pre class="r"><code>pr2 &lt;- 1-(resid.dev/null.dev)
pr2.test &lt;- 1-(resid.dev.test/null.dev.test)
print(pr2.test)</code></pre>
<pre><code>## [1] 0.07760427</code></pre>
<p>The model only explains about 7.7–8.7% of the deviance; it’s not a highly predictive model (you should have suspected that already, from figure 7.9). This tells us that we haven’t yet identified all the factors that actually predict at-risk births.</p>
<p>The model only explains about 7.7–8.7% of the deviance; it’s not a highly predictive model (you should have suspected that already, from figure 7.9). This tells us that we haven’t yet identified all the factors that actually predict at-risk births. The Fisher scoring method is an iterative optimization method similar to Newton’s method that glm() uses to find the best coefficients for the logistic regression model. You should expect it to converge in about six to eight iterations. If there are more iterations than that, then the algorithm may not have converged, and the model may not be valid.</p>
</div>
<div id="separation-and-quasi-separation" class="section level3">
<h3>Separation and quasi-separation</h3>
<p>The probable reason for nonconvergence is separation or quasi-separation: one of the model variables or some combination of the model variables predicts the outcome perfectly for at least a subset of the training data. You’d think this would be a good thing, but ironically logistic regression fails when the variables are too powerful. Ideally, glm() will issue a warning when it detects separation or quasi-separation:</p>
<pre><code>Warning message: glm.fit: fitted probabilities numerically 0 or 1 occurred</code></pre>
<p>Unfortunately, there are situations when it seems that no warning is issued, but there are other warning signs:  * An unusually high number of Fisher iterations * Very large coefficients, usually with extremely large standard errors * Residual deviances larger than the null deviances</p>
<p>If you see any of these signs, the model is suspect. To try to fix the problem, remove any variables with unusually large coefficients; they’re probably causing the separation. You can try using a decision tree on the variables that you remove to detect regions of perfect prediction. The data that the decision tree doesn’t predict perfectly on can still be used for building a logistic regression model. The overall model would then be a hybrid: the decision tree to predict the too-good data, and a logistic regression model for the rest.</p>
<p>What you should remember about logistic regression:</p>
<ul>
<li>Logistic regression is the go-to statistical modeling method for binary classification.</li>
<li>Try logistic regression first, and then more complicated methods if logistic regression doesn’t perform well.</li>
<li>Logistic regression will have trouble with problems with a very large number of variables, or categorical variables with a very large number of levels.</li>
<li>Logistic regression is well calibrated: it reproduces the marginal probabilities of the data.</li>
<li>Logistic regression can predict well even in the presence of correlated variables, but correlated variables lower the quality of the advice.</li>
<li>Overly large coefficient magnitudes, overly large standard errors on the coefficient estimates, and the wrong sign on a coefficient could be indications of correlated inputs.</li>
<li>Too many Fisher iterations, or overly large coefficients with very large standard errors, could be signs that an input or combination of inputs is perfectly correlated with a subset of your responses. You may have to segment the data to deal with this issue. <em> glm() provides good diagnostics, but rechecking your model on test data is still your most effective diagnostic. </em> Pseudo R-squared is a useful goodness-of-fit heuristic.</li>
</ul>
</div>

</div> <!-- lessonContent -->
</div> <!-- lessonPage -->


<script type="text/javascript">
  var lesson = window.location.href.match(/lesson-[0-9]+/g);
  if (lesson !== null) {
    lesson = 'nav-' + lesson[0];
    $('#'+lesson).addClass('current');
  }

  $('#show-answer').on("click", function() {
    $('#show-answer').addClass('showing');
    $('#model-answer').addClass('showing');
  })
</script>
  </div> <!-- articleBandContent -->
</div> <!-- pageContent -->

<div id="rStudioFooter" class="band full">
<div class="bandContent">
  <div id="copyright">Создано с помощью R в Лаборатории Агроэкологического Мониторинга и Прогнозирования экосистем - <a href="http://lamp-lab.ru">ЛАМП</a></div>
  <div id="logos">
  <!-- <a href="https://twitter.com/rstudio" class="footerLogo twitter"></a>-->
  <!-- <a href="https://github.com/rstudio" class="footerLogo gitHub"></a>-->
  <!-- <a href="https://www.linkedin.com/company/rstudio-inc" class="footerLogo linkedIn"></a>-->
  <!--  <a href="https://www.facebook.com/pages/RStudio-Inc/267733656584415" Class="footerLogo facebook"></a> -->
  </div>
</div>
</div>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
